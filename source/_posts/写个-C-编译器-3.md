title: 写个 C 编译器（3）——词法分析器
date: 2015-12-22 12:03:14
tags: [C, compiler]
categories: Project
toc:
---

这是“写个 C 编译器”系列的第三篇，本篇中我们将讲解如何构建词法分析器。

# 基本概念

一般来说，如果上网搜索“如何写编译器”，得到的结果中有许多是关于“词法分析器”。那
么什么是“词法分析器”？为什么我们需要它呢？

首先我们需要知道的是，当编译器读取源代码文件时，它得到的是一个很长的字符串。
直接对这个字符串进行分析往往会很困难。

例如，对于字符串 `'998'`，直接分析的话就需要去分析：好，是三个数字一起出现，
所以我们得到的是一个数字，它的值是 998。

然而，实际上由于编译器需要对这些字符串的语义（语法分析）进行分析，而这部分工作
往往已经十分复杂，如果仍然需要对输入一个字符一个字符地分析。那么写出来的编译器
会显得十分复杂，且难以维护。由于这部分分析相对独立，因此我们可以将它独立成一个
模块，这就是“词法分析器（lexer）”。

所以，“词法分析器”是事先对源代码进行分析，得到一个标记流（token stream）。标记
流是语法分析更容易理解的记号。

“词法分析器”存在的目的是减少语法分析器的复杂度。本身并不是必要的。

好吧，我知道我是说不清楚的。如果依旧不明白的话，请自行查看其它的书籍吧。

# 词法分析器的实现

由于词法分析的工作很常见，所以人们已经开发出了许多工具来自动生成，如 `lex/flex`。
这些工具允许我们通过指定各个标记对应的正则表达式来得到标记流。

但是这些工具太强大了，所以我们不用，因为我们的编译器是以学习为目的的。我们要
手工地写一个。

这里还要注意的一点是，我们并不会实现一个完整的词法分析器，如我们会把左括号 `(`
转化成标记 `Brak`，但却不会转化右括号`)`。原因在于这并不是必需的，所以在实现时
请注意这点：词法分析器只是为了减小语法分析器的复杂程度。

## 词法分析器的框架

即 `next()` 函数的主体。

```
int *src;  // pointer to source code string;
int line;  // line number of source code
void next() {
    char *last_pos;
    while (token = *src) {
        ++src;

        if (token == '\n') {
            ++line;
        }

        // skip empty line or comment line
        return;
    }
}
```

while 循环发生在包含空行时或是注释行时。

## 标识符(identifier) 与符号表

在 C 语言中，我们用字符串代表变量名或称标识符（哪个语言不是啊喂）。具体而言是
以字母或下 划线'_'开始，后面可以接字母、数字及下划线。实际生成代码的时候，我们
其实并不在 乎它具体叫什么名字（即具体的字符串是什么），在乎只是它所代表的唯一
标识。

基于此，我们希望把在源代码中遇到的标识符都存放在一张表里，遇到新的标识符时就查
这张表，如果该标识符已经存在，则返回它的唯一标识。

好吧，文字太多了，来点代码吧。首先是关于数据结构的。

```
struct identifier {
    int token;
    int hash;
    char * name;
    int class;
    int type;
    int value;
    int Bclass;
    int Btype;
    int Bvalue;
}
```

这里解释一下具体的含义：

1. `token`：该标识符返回的标记，理论上所有的变量返回的标记都应该是 `Id`，但实
   际上由于我们还将在符号表中加入关键字如 `if`, `while` 等，它们都有对应的标
   记。
2. `hash`：顾名思义，就是这个标识符的哈希值，用于在符号表中快速查找。
3. `name`：存放标识符本身的字符串。
4. `class`：该标识符的类别，如数字，全局变量或局部变量等。
5. `type`：标识符的类型，即如果它是个变量，变量是 `int` 型、`char` 型还是指针
   型。
6. `value`：存放这个标识符的值，如标识符是函数，刚存放函数的地址。
7. `BXXXX`：C 语言中标识符可以是全局的也可以是局部的，当局部标识符的名字与全局
   标识符相同时，用作保存全局标识符的信息。

由上可以看出，我们实现的词法分析器与传统意义上的词法分析器不太相同。如这里的
符号表我们不仅用来存储标识符本身，还用于存储语法分析时会使用的信息。

由于我们的目标是能自举，而我们定义的语法不支持 `struct`，故而使用下列方式。

```
Symbol table:
----+-----+----+----+----+-----+-----+-----+------+------+----
 .. |token|hash|name|type|class|value|btype|bclass|bvalue| ..
----+-----+----+----+----+-----+-----+-----+------+------+----
    |<---       one single identifier                --->|
```

即用一个整型数组来保存相关的ID信息。每个ID占用数组中的9个空间，分析标识符的相
关代码如下：

```c
void next() {
        ...

        else if ((token >= 'a' && token <= 'z') || (token >= 'A' && token <= 'Z') || (token == '_')) {
            // parse identifier
            last_pos = src - 1;
            hash = token;

            while ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9') || (*src == '_')) {
                hash = hash * 147 + *src;
                src++;
            }

            // look for existing identifier, linear search
            current_id = symbols;
            while (current_id[Token]) {
                if (current_id[Hash] == hash && !memcmp((char *)current_id[Name], last_pos, src - last_pos)) {
                    //found one
                    token = current_id[Token];
                    return;
                }
                current_id += IdSize;
            }

            // store new ID
            current_id[Name] = (int)last_pos;
            current_id[Hash] = hash;
            token = current_id[Token] = Id;
            return;
        }

        ...
}
```

## 字符串的处理

在分析时，如果分析到字符串，我们需要将它存放到前一篇文章中说的 `data` 段中。
另一个特殊的地方是我们需要支持转义符。例如用 `\n` 表示换行符。由于本编译器的
目的是达到自己编译自己，所以代码中并没有支持除 `\n` 的转义符，如 `\t`, `\r`
等，但仍支持 `\a` 表示字符 `a` 的语法。

在分析时，我们将同时分析单个字符如 `'a'` 和字符串如 `"a string"`。若得到的是
单个字符，我们以 `Num` 的形式返回。相关代码如下：

```c
        else if (token == '\"' || token == '\'') {
            // parse string literal, currently, the only supported escape
            // character is '\n', store the string literal into data.
            last_pos = data;
            while (*src != 0 && *src != token) {
                if ((token_val = *src++) && (token_val == '\\')) {
                    // escape character
                    if ((token_val = *src++) && (token_val == 'n')) {
                        token_val = '\n';
                    }
                }

                if (token == '\"') {
                    *data++ = token_val;
                }
            }

            // if it is a single character, return Num token
            if (token == '\"') {
                token_val = (int)last_pos;
            } else {
                token = Num;
            }
        }
```

## 数字

数字中较为复杂的一点是需要支持十进制、十六进制及八进制。逻辑也较为直接，可能
唯一不好理解的是获取十六进制的值相关的代码。

```
token_val = token_val * 16 + (token & 16) + (token >= 'A' ? 9 : 0);
```

这里要注意的是在ASCII码中，字符`a`对应的十六进制值是 `61`, `A`是`41`，故通过
`(token & 16)` 可以得到个位数的值。其它就不多说了，这里这样写的目的是装B（其实
是抄 c4 的源代码的）。

相关代码如下：

```c
        else if (token >= '0' && token <= '9') {
            // parse number, three kinds: dec(123) hex(0x123) oct(017)
            token_val = token - '0';
            if (token_val) {
                if (*src == 'x' || *src == 'X') {
                    //hex
                    token = *++src;
                    while ((token >= '0' && token <= '9') || (token >= 'a' && token <= 'f') || (token >= 'A' && token <= 'F')) {
                        token_val = token_val * 16 + (token & 16) + (token >= 'A' ? 9 : 0);
                        token = *++src;
                    }
                } else {
                    // dec
                    while (*src >= '0' && *src <= '9') {
                        token_val = token_val*10 + *src++ - '0';
                    }
                }
            } else {
                // oct
                while (*src >= '0' && *src <= '7') {
                    token_val = token_val*8 + *src++ - '0';
                }
            }

            token = Num;
            return;
        }
```

## 其它

词法分析器剩余的部分就十分直观了。就是分析源码字符串是是否出现特定的字符，返回
对应的标记值。最终的 `next()` 函数如下：

```c
void next() {
    char *last_pos;
    int hash;
    while (token = *src) {
        ++src;

        if (token == '\n') {
            ++line;
        }
        else if (token == '#') {
            // skip macro, because we will not support it
            while (*src != 0 && *src != '\n') {
                src++;
            }
        }
        else if ((token >= 'a' && token <= 'z') || (token >= 'A' && token <= 'Z') || (token == '_')) {
            // parse identifier
            last_pos = src - 1;
            hash = token;

            while ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9') || (*src == '_')) {
                hash = hash * 147 + *src;
                src++;
            }

            // look for existing identifier, linear search
            current_id = symbols;
            while (current_id[Token]) {
                if (current_id[Hash] == hash && !memcmp((char *)current_id[Name], last_pos, src - last_pos)) {
                    //found one, return
                    token = current_id[Token];
                    return;
                }
                current_id += IdSize;
            }

            // store new ID
            current_id[Name] = (int)last_pos;
            current_id[Hash] = hash;
            token = current_id[Token] = Id;
            return;
        }
        else if (token >= '0' && token <= '9') {
            // parse number, three kinds: dec(123) hex(0x123) oct(017)
            token_val = token - '0';
            if (token_val) {
                if (*src == 'x' || *src == 'X') {
                    //hex
                    token = *++src;
                    while ((token >= '0' && token <= '9') || (token >= 'a' && token <= 'f') || (token >= 'A' && token <= 'F')) {
                        token_val = token_val * 16 + (token & 16) + (token >= 'A' ? 9 : 0);
                        token = *++src;
                    }
                } else {
                    // dec
                    while (*src >= '0' && *src <= '9') {
                        token_val = token_val*10 + *src++ - '0';
                    }
                }
            } else {
                // oct
                while (*src >= '0' && *src <= '7') {
                    token_val = token_val*8 + *src++ - '0';
                }
            }

            token = Num;
            return;
        }
        else if (token == '/') {
            if (*src == '/') {
                // skip comments
                while (*src != 0 && *src != '\n') {
                    ++src;
                }
            } else {
                // divide operator
                token = Div;
                return;
            }
        }
        else if (token == '\"' || token == '\'') {
            // parse string literal, currently, the only supported escape
            // character is '\n', store the string literal into data.
            last_pos = data;
            while (*src != 0 && *src != token) {
                if ((token_val = *src++) && (token_val == '\\')) {
                    // escape character
                    if ((token_val = *src++) && (token_val == 'n')) {
                        token_val = '\n';
                    }
                }

                if (token == '\"') {
                    *data++ = token_val;
                }
            }

            // if it is a single character, return Num token
            if (token == '\"') {
                token_val = (int)last_pos;
            } else {
                token = Num;
            }
        }
        else if (token == '=') {
            // parse '==' and '='
            if (*src == '=') {
                src ++;
                token = Eq;
            } else {
                token = Assign;
            }
            return;
        }
        else if (token == '+') {
            // parse '+' and '++'
            if (*src == '+') {
                src ++;
                token = Inc;
            } else {
                token = Add;
            }
            return;
        }
        else if (token == '-') {
            // parse '-' and '--'
            if (*src == '-') {
                src ++;
                token = Dec;
            } else {
                token = Sub;
            }
            return;
        }
        else if (token == '!') {
            // parse '!='
            if (*src == '=') {
                src++;
                token = Ne;
            }
            return;
        }
        else if (token == '<') {
            // parse '<=', '<<' or '<'
            if (*src == '=') {
                src ++;
                token = Le;
            } else if (*src == '<') {
                src ++;
                token = Shl;
            } else {
                token = Lt;
            }
            return;
        }
        else if (token == '>') {
            // parse '>=', '>>' or '>'
            if (*src == '=') {
                src ++;
                token = Ge;
            } else if (*src == '>') {
                src ++;
                token = Shr;
            } else {
                token = Gt;
            }
            return;
        }
        else if (token == '|') {
            // parse '|' or '||'
            if (*src == '|') {
                src ++;
                token = Lor;
            } else {
                token = Or;
            }
            return;
        }
        else if (token == '&') {
            // parse '&' and '&&'
            if (*src == '&') {
                src ++;
                token = Lan;
            } else {
                token = And;
            }
            return;
        }
        else if (token == '^') {
            token = Xor;
            return;
        }
        else if (token == '%') {
            token = Mod;
            return;
        }
        else if (token == '*') {
            token = Mul;
            return;
        }
        else if (token == '[') {
            token = Brak;
            return;
        }
        else if (token == '?') {
            token = Cond;
            return;
        }
        else if (token == '~' || token == ';' || token == '{' || token == '}' || token == '(' || token == ')' || token == ']' || token == ',' || token == ':') {
            // directly return the character as token;
            return;
        }
    }
}
```

# 小结

词法分析器本身的内容是比较简单的，尤其是自己实现的时候。而相对的，一般网上搜索
或书本中的知识就显得十分复杂，原因是它们使用的是更加高效、通用的方法。

如果你经常自己手写词法分析器，你就会发现这是件无聊且容易出错的工作，这时，你就
可以寻求一些工具的帮助了。

希望你能通过本节的例子，对词法分析器的编写有一定的认识。它并不是十分困难的东
西。

下节中，我们将开始语法分析器的编写，敬请期待。
