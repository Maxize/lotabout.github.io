title: 写个 C 编译器（1）——动机、语法、设计
date: 2015-12-22 12:03:14
tags: [C, compiler]
categories: Project
toc:
---

很久之前看到 Github 上有个项目叫 [c4](https://github.com/rswier/c4)，用4个函数
写了一个 C 的编译器（严格上说是解释器），最终完成自举（用编译后的编译器编译自己的代码）。
行数共记500+。

问题是它的代码比较乱（相当乱），因为它的初衷是 'minimal'。最近没什么人生目标，
想着就试图仿照它的思路自己写一个 C 的编译器（其实是解释器）。

<!--more-->

本文假设你已经了解了 C 语言的基本知识，会使用 C 语言进行编程，且有一定的编译原
理的基础，知道一些编译原理的概念，因为有助于理解。另外，文章的撰写和代码是同
步进行的，所以开始的代码并不保证与最终结果相 同。

# 语法

主要包括类型、语法、运算符及内置函数。不过既然说了是仿照，那这里其实就是把 c4
中的设计解释一下。

## 支持的类型

因为要完成自举，所以意味着最终的成品要能编译我们写的代码。所以在写这个编译器时
时，要限制我们自己能使用的特性。

因此我们只使用 3 种类型：`char`, `int` 及 `pointer`。即字符、整型和指针。

## 语法

这里的语法更多指的是语句。

我们将内置 3 种语句：`if`, `while` 及 `return`。当然我们还需要支持定义函数，及
表达式运算。这里解释下“语句”和“表达式”间的区别。如下列 C 代码：

```
if (1 + 1 == 2) {
    x += 1;
}
```

`if (...) {...}` 就是一个语句。而 `1+1==2` 就是一个表达式。表达式必须放在语句
中，上例中 `x += 1` 是一个表达式，如果没有末尾的 `;` ，就会产生语法错误。这也
说明了，要将表达式转换成语句，在后面加上 `;` 就可以了。

## 运算符

支持的运算符有：`=`, `||`, `&&`, `==`, `!=`, `<`, `>`, `<=`, `>=`, `<<`, `>>`,
`+`, `-`, `*`, `/`, `%`, `++`, `--`, `[`。其中`[`表示数组的取值操作

## 内置函数

由于要读写文件，操作内存，输出等。我们要支持一些内置的函数。有：`open`,
`close`, `read`, `printf`, `malloc`, `memset`, `memcmp` 及 `exit`。

## 另外

另外，`//` 表示注释。以字符 `#` 开头的行也被当作注释处理，但在 C 语言中它是作
为宏来使用的，如 `#include <stdio.h>`。

# 设计

一般而言，编译器的编写分为 3 个步骤：

1. 词法分析器，用于将字符串转化成内部的表示结构。
2. 语法分析器，将词法分析得到的标记流（token）生成一棵语法树。
3. 目标代码的生成，将语法树转化成目标代码。

已经有许多工具能帮助我们处理阶段1和2，如 flex 用于词法分析，bison 用于语法分
析。

只是它们的功能都过于强大，对于我们理解早期大牛们是如何构造出最早的编译器帮助不
大。所以我们要完全手写这些功能。但由于是完全自己实现，所以我们的代码有如下特点：

1. 词法分析与语法分析是同时进行的。
2. 我们写的是解释器，所以要自己解释生成的代码。

## 编译器结构

好吧，其实这里应该说很多理论相关的，但我知道你是看代码来的，所以下面就用代码说
话吧。

首先，就像 c4(c in 4 functions) 的名字一样，我们的编译器包含4个主要的函数：

1. `statement()` 用于解析一个 C 语句。
2. `expression(level)` 用于解析一个 C 的表达式。
3. `next()` 用于词法分析，获取下一个标记(token)。
4. `eval()` 用于解析生成的代码。

我们把几乎所有的变量都设置为全局，方便访问。所以现在的结构如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>

int token; // current token

void next() {
    token = 0;
}

void expression(int level) {

}

void statement() {

}

void eval() {

}

int main(int argc, char *argv[])
{
    next();

    while (token) {
        statement();
    }

    eval();

    return 0;
}
```

具体要怎么实现其中的功能，且听下回分解。
