title: 写个 C 编译器（2）——解释器的结构
date: 2015-12-22 12:03:14
tags: [C, compiler]
categories: Project
toc:
---

这是“写个 C 编译器”系列的第二篇，本篇中我们将讲解如何解析我们的编译器将的代
码。或者说是如何创建一个虚拟机。

好吧，如果你学过汇编，那我们的任务就是实现一套简单的汇编指令。详细的 x86 汇编
指令参见：[x86asm.net](http://ref.x86asm.net/coder.html)

# 计算机的内部结构

代码以二进制的形式保存在计算机的内存中。CPU 一条指令一条指令地加载，并适时地
访问其中的数据。正常的情况下，一个进程中，内存被分成几个特殊的段：代码段
（text）、数据段（data）、未初始化数据段（bss）、栈（stack）及堆（heap）。而
内部的寄存器中：

1. `PC` 永远指向下一条待执行的指令，
2. `SP` 永远指向当前的栈顶，
3. `BP` 指向当栈的基准地址，其实就是能修改，`SP` 不能被程序修改。
4. `AX` 将用来存储指令的执行结果。

因此，我们的解释器要模拟其中的：代码段、数据段及栈，用操作系统提供的堆，以及上
述的4种寄存器。

首先，我们在文件开始处加入定义：

```c
int *text, // text segment
    *data, // data segment
    *stack; // stack

int poolsize; // default size of text/data/stack
int *pc, *bp, *sp, ax, cycle; // virtual machine registers
```

在 `main` 函数中加入初始化代码：

```c
int main(...) {
    ...

    poolsize = 256 * 1024; // arbitrary size

    // allocate memory
    if (!(text = malloc(poolsize))) {
        printf("could not malloc(%d) for text area\n", poolsize);
        return -1;
    }
    if (!(data = malloc(poolsize))) {
        printf("could not malloc(%d) for data area\n", poolsize);
        return -1;
    }
    if (!(stack = malloc(poolsize))) {
        printf("could not malloc(%d) for stack area\n", poolsize);
        return -1;
    }
    memset(text, 0, poolsize);
    memset(data, 0, poolsize);
    memset(stack, 0, poolsize);

    ...
}
```

# 指令集

指令集是 CPU 能识别的命令的集合，也可以说是 CPU 能理解的语言。这里，我们要为我
们的虚拟机构建自己的指令集。基于 x86 的指令集，但要更为简单。

## MOV

`MOV` 指令用于将数据放进寄存器或内存地址，有点类似于 C 语言中的赋值语句。x86
的 `MOV` 指令有两个参数，分别是源地址和目标地址：`MOV dest, source` （Intel 风
格）。

但我们的小虚拟机只有一个寄存器，所以我们对它进行简化：

1. `IMM <num>` 将 `<num>` 放入寄存器 `ax` 中。
2. `LC` 将对应地址中的字符载入 `ax` 中，要求 `ax` 中存放地址。
3. `LI` 将对应地址中的整数载入 `ax` 中，要求 `ax` 中存放地址。
4. `SC` 将 `ax` 中的数据作为字符存放入地址中，要求栈顶存放地址。
5. `SI` 将 `ax` 中的数据作为整数存放入地址中，要求栈顶存放地址。

你可能觉得，这不是坑爹吗，一个指令变成了这么多指令。一方面呢，`MOV` 指令其实有
许多变种，根据类型的不同又有 `MOVB`, `MOVW` 等，我们这里的 `LC` 和 `LI` 就是对
两种类型分别生成一条指令。

在 `eval()` 函数中加入下列代码：

```c
void eval() {
    int op;
    while (1) {
        op = *pc++; // get next operation code
        if (op == IMM) {ax = *pc++;}                      // load immediate value to ax
        else if (op == LC) {ax = *(char *)ax;}            // load character to ax, address in ax
        else if (op == LI) {ax = *(int *)ax;}             // load integer to ax, address in ax
        else if (op == SC) {ax = *(char *)*sp++ = ax;}    // save character to address, value in ax, address on stack
        else if (op == SI) {*(int *)*sp++ = ax;}          // save integer to address, value in ax, address on stack
    }
}
```

这里要解释的一点是，为什么 `SI/SC` 指令中，地址存放在栈中，而 `LI/LC` 中，地址
存放在 `ax` 中？原因是默认计算的结果是存放在 `ax` 中的，而地址通常是需要通过
计算获得，所以执行 `LI/LC` 时直接从 `ax` 取值会更高效。另一点是我们的 `PUSH`
指令只能将 `ax` 的值放到栈上，而不能以值作为参数，详细见下文。

## PUSH

在 x86 中，`PUSH ` 的作用是将值或寄存器，而在我们的虚拟机中，一方面只有一个寄
存器，另一方面为了简化实现，因此规定它的作用是将 `ax` 的值放入栈中。代码如下：

```c
        else if (op == PUSH) {*--sp = ax;}                // push the value of ax onto the stack
```

## JMP

`JMP <addr>` 是跳转指令，无条件地将当前的 `PC` 寄存器设置为指定的 `<addr>`，实现如下：

```
        else if (op == JMP) {pc = (int *)*pc;}            // jump to the address
```

## JZ/JNZ

为了实现 `if` 语句，我们需要条件判断相关的指令。这里我们只实现两个最简单的条件
判断，即结果（`ax`）为零或不为零情况下的跳转。

实现如下：

```c
        else if (op == JZ) {pc = ax ? pc + 1 : (int *)pc;} // jump if ax is zero
        else if (op == JNZ) {pc = ax ? (int *)pc : pc + 1;} // jump if ax is zero
```

## 子函数调用

这块是汇编中最难理解的部分，所以合在一起说，要引入的命令有 `CALL`, `LEV`,
`ENT`。

首先我们介绍 `CALL <addr>` 与 `RET` 指令，它们的作用是调用存放在 `<addr>` 上的
子函数，以及从子函数中返回。

为什么不能直接用 `JMP` 指令呢？原因是当我们从子函数中返回时，程序需要从跳转前
的地方继续运行，这便需要事先将这个位置信息存储起来。反过来，子函数要返回时，就
需要获取并恢复这个信息。因此实际中我们将 `PC` 保存在栈中。如下：

```c
        else if (op == CALL) {*--sp = (int)(pc+1); pc = (int *)*pc;} // call subroutine
        else if (op == RET) {pc = (int *)*sp++;}          // return from subroutine;
```

这一切多么美好。只是实际调用函数时，还要考虑如何传递参数和如何返回结果。这里我
们约定，如果子函数有返回结果，那么就在返回时保存在 `ax` 中。那么参数的传递呢？

各种编程语言关于如何调用子函数有不同的约定，这里我们采用类似C语言的标准：

1. 由调用者将参数入栈。
2. 调用结束时，由调用者将参数出栈。
3. 参数逆序入栈。但我们是用正序入栈

下面的例子取自 [维基百科](https://en.wikipedia.org/wiki/X86_calling_conventions)：

```c
int callee(int, int, int);

int caller(void)
{
	int ret;

	ret = callee(1, 2, 3);
	ret += 5;
	return ret;
}
```

会生成如下的 x86 汇编代码：

```assembly
caller:
	; make new call frame
	push    ebp
	mov     ebp, esp
	; push call arguments
	push    3
	push    2
	push    1
	; call subroutine 'callee'
	call    callee
	; remove arguments from frame
	add     esp, 12
	; use subroutine result
	add     eax, 5
	; restore old call frame
        mov     esp, ebp
	pop     ebp
	; return
	ret
```

上面这段代码在我们自己的汇编语言里会有几个问题：

1. `push ebp`，但我们的 `PUSH` 指令并无法指定寄存器。
2. `mov ebp, esp`，我们的 `MOV` 指令同样功能不足。
3. `add esp, 12`，也是一样的问题（尽管我们还没定义）。

一方面，因此我们的指令集完成不了这些功能，另一方面，这些代码又需要经常发生，
因此我们加入这几个指令：

### ENT

`ENT <size>` 指的是 `enter`，用于实现 'make new call frame' 的功能，即保存当前的栈指
针。对应的汇编代码为：

```
	; make new call frame
	push    ebp
	mov     ebp, esp
        subl    esp, 3     ; save stack for local variables
```

实现如下：

```c
        else if (op == ENT) {*--sp = (int)bp; bp = sp; sp = sp - *pc++;}  // make new stack frame
```

### ADJ

`ADJ <size>` 用于实现 'remove arguments from frame'。在将调用子函数时压入栈中
的数据清除，本质上是因为我们的 `ADD` 指令功能有限。对应的汇编代码为：

```
	; remove arguments from frame
	add     esp, 12
```

实现如下：

```
        else if (op == ADJ) {sp = sp + *pc++;}            // add esp, <size>
```

### LEV

本质上并不需要这个指令，只是我们的指令集中并没有 `POP` 指令。并且两条指令写起
来也比较麻烦，所以用一个指令代替。对应的汇编指令为：

```
	; restore old call frame
        mov     esp, ebp
	pop     ebp
	; return
	ret
```

具体的实现如下：


```c
        else if (op == LEV) {sp = bp; bp = (int *)*sp++; pc = (int *)*sp++;}  // restore call frame and PC
```

### LEA

上面的一些指令解决了调用帧的问题，但还有一个问题是如何在子函数中获得传入的参
数。这里我们首先要了解的是当参数调用时，栈中的调用帧是什么样的。我们依旧用上面
的例子（只是参数的顺序不一样）：

```
|    ....       | high address
+---------------+
| arg: 1        |
+---------------+
| arg: 2        |
+---------------+
| arg: 3        |
+---------------+
|return address |
+---------------+
| old BP        | <- new BP
+---------------+
| local var 1   |
+---------------+
| local var 2   |
+---------------+
|    ....       |  low address
```

所以为了获取第一个参数，我们需要得到 `new_bp + 4`，但如上所述，我们的 `ADD`
指令无法实现此功能，所以我们提供一个新的指令：`LEA <offset>`

实现如下：

```c
        else if (op == LEA) {ax = (int)(bp + *pc++);}     // load address for arguments.
```

## 运算符指令

我们为 C 语言中支持的运算符都提供对应汇编指令。每个运算符都
是二元的，即有两个参数，第一个参数放在栈顶，第二个参数放在 `ax` 中。这个顺序要
特别注意。因为像 `-`, `/` 之类的运算符是与参数顺序有关的。计算后会将栈顶的参数
退栈。

实现如下：

```c
        else if (op == OR)  ax = *sp++ | ax;
        else if (op == XOR) ax = *sp++ ^ ax;
        else if (op == AND) ax = *sp++ & ax;
        else if (op == EQ)  ax = *sp++ == ax;
        else if (op == NE)  ax = *sp++ != ax;
        else if (op == LT)  ax = *sp++ < ax;
        else if (op == LE)  ax = *sp++ <= ax;
        else if (op == GT)  ax = *sp++ >  ax;
        else if (op == GE)  ax = *sp++ >= ax;
        else if (op == SHL) ax = *sp++ << ax;
        else if (op == SHR) ax = *sp++ >> ax;
        else if (op == ADD) ax = *sp++ + ax;
        else if (op == SUB) ax = *sp++ - ax;
        else if (op == MUL) ax = *sp++ * ax;
        else if (op == DIV) ax = *sp++ / ax;
        else if (op == MOD) ax = *sp++ % ax;
```

## 内置函数

正常情况下，一些函数是通过预先编译好的子函数实现的。为了方便起见，我们直接提供
相应的汇编指令来实现。这里先实现 `EXIT` 退出指令。剩下的遇到的时候再增加。

```c
        else if (op == EXIT) { printf("exit(%d)", *sp); return *sp;}
```

# 测试

在开头添加指令集的定义：

```c
// instructions
enum {IMM, LC, LI, SC, SI, PUSH, JMP, JZ, JNZ, CALL, RET, ENT, ADJ, LEV, LEA,
      OR, XOR, AND, EQ, NE, LT, LE, GT, GE, SHL, SHR, ADD, SUB, MUL, DIV, MOD,
      EXIT};
```

这样代码就使用了。

下面我们用我们的汇编写一小段程序，来计算 `10+20`，在 `main` 函数中加入下列代
码：

```
int main(int argc, char *argv[])
{
    ...
    memset(stack, 0, poolsize);

    sp = bp = stack;

    int i = 0;
    data[i++] = IMM;
    data[i++] = 10;
    data[i++] = PUSH;
    data[i++] = IMM;
    data[i++] = 20;
    data[i++] = ADD;
    data[i++] = PUSH;
    data[i++] = EXIT;

    pc = data;

    next();
    ...
}
```

编译程序 `gcc -o xc xc.c`，运行程序：`./xc`。输出

```
exit(30)
```

本节完整的代码可以在 https://github.com/lotabout/write-a-C-interpreter/releases/tag/v0.2 上找到。

# 小结

本节中我们尝试创建了我们自己的虚拟机，实现了自己的汇编指令集，虽然没有 x86
指令集那么强大，但功能也是足够的。我们将用这些指令来作为编译程序输出的指令。

题外话，一般关于编译器的教程一般到如何从语法树生成代码就结束了，没有告诉我们这
些代码是如何真正运行的。所以希望本节的内容能解答你的一些疑惑。下一节开始，我们
就要“真正”进入编译器的实现了。
